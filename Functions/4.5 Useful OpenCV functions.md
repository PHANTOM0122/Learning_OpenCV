Chapter 4.5 Useful OpenCV functions
====================================

### 마스크 연산에 대한 소개 및 영상 합성 프로그램 make!

### Mask 연산이란?

> 영상의 일부 영역에 대해서만 특정 연산을 수행할 수 있다.

### 4.5-1 마스크 연산

> 임의의 모양을 갖는 ROI 설정 하는 곳에 사용!
> 주로 CV_8U인 마스크 영상을 함께 인자로 전달받는다.
> 영상의 픽셀이 0이 아닌 좌표에 대해서만 연산이 수행

#### Mat::setTo() 함수
<pre>
<code>
Mat& MAt::SetTo(InputArray value, InputArray mask = noArray());
</code>
</pre>
* value : 행렬 원소에 설정할 값
* mask : 마스크 행렬, **마스크 행렬의 값이 0이 아닌 위치에서만 value값이 설정된다.**
* 반환값 : Mat 객체

##### Example code // lenna 사진에 스마일 사진 합성
<pre>
<code>
void mask_setTo() {
	Mat src = imread("lenna.bmp", IMREAD_COLOR);
	Mat mask = imread("mask_smile.bmp", IMREAD_GRAYSCALE);

	if (src.empty() || mask.empty()) {
		cerr << "Image load failed!" << endl;
		return;
	}

	src.setTo(Scalar(0, 255, 255), mask); // (검은색 부분이 아닌 픽셀에 대해서만 노란색으로 변경)

	imshow("src", src);
	imshow("mask", mask);

	waitKey();
	destroyAllWindows();
}
</code>
</pre>

#### Mat::copyTo() 함수
<pre>
<code>
void Mat::copyTo(OnputArray m, InputArray mask mask) const;
</code>
</pre>
* m : 복사본이 저장될 행렬. 만약 this 행렬과 크기 및 타입이 다르면 메모리를 새로 할당한 후 픽셀 값을 복사 
* mask : 마스크 행렬, *마스크 행렬의 값이 0이 아닌 위치에서만 value값이 설정된다. **this* 와 같은 크기여야 하며 깊이는 CV_8U어야 한다.
##### Example code // 비행기 영상과 들판 사진을 이용하여 합성
<pre>
<code>
void mask_copyTo() {
	Mat src = imread("airplane.bmp", IMREAD_COLOR);
	Mat mask = imread("mask_plane.bmp", IMREAD_GRAYSCALE);
	Mat dst = imread("field.bmp", IMREAD_COLOR);

	if (src.empty() || mask.empty() || dst.empty()) {
		cerr << "Image load failed!" << endl;
		return;
	}

	src.copyTo(dst, mask); // mask 영상에서 흰색으로 표현된 위치에서만 src 영상의 픽셀값이 dst영상으로 복사된다!

	imshow("dst", dst);
	waitKey();
	destroyAllWindows();
}
</code>
</pre>


### 4.5-2 연산 시간 측정

#### 1) getTickCount(), getTickFrequency() 함수를 사용하는 방법
<pre>
<code>
int64 getTickCount(void);
</code>
</pre>
* 반환값 : 시스템의 현재 Tick 횟수
<pre>
<code>
double getTickFrequency(void);
</code>
</pre>
* 반환값 : 시스템의 초당 Tick 횟수
##### Example code
<pre>
<code>
int64 t1 = getTickCount();
my_func(); // Do something
int64 t2 = getTickCount();
double ms = (t2-t1) * 1000 / getTickFrequency(); // 연산 시간에 1000을 곱하여 밀리초 단위의 연산 시간을 변수 ms에 저장!
</code>
</pre>

#### 2) TickMeter class를 사용하는 방법
##### Example code 1
<pre>
<code>
TickMeter tm;
tm.start();
my_func(); // Do something!
tm.stop();
double ms = tm.getTimeMill // 밀리초 단위의 연산 시간을 get!
</code>
</pre>

##### Example code 2 
<pre>
<code>
void time_inverse() {
	Mat src = imread("lenna.bmp", IMREAD_GRAYSCALE);
	if (src.empty()) {
		cerr << "Image load failed!" << endl;
		return;
	}

	Mat dst(src.rows, src.cols, src.type());

	TickMeter tm;
	tm.start();

	for (int j = 0; j < src.rows; j++) {
		for (int i = 0; i < src.cols; i++) {
			dst.at<uchar>(j, i) = 255 - src.at<uchar>(j, i);
		}
	}

	tm.stop();
	cout << "Imate inverse took " << tm.getTimeMilli() << "ms. " << endl;
}
</code>
</pre>
